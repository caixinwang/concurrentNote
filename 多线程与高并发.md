# 多线程与高并发

`https://gitee.com/caixin-wang/juc.git`

## 线程基础知识

大家都知道这个CPU这东西呢，是人民发明出来用来做计算的，那好，既然你是给我做计算的，我当然要把你的计算性能压榨到最高啊，不让你闲着

 <img src="image/image-20230315194530988.png" alt="image-20230315194530988" style="zoom:67%;" />

多进程的并行处理是操作系统诞生之后，基本上采用的一种对CPU性能的压榨的通用的手段。

我们这儿内存里面有程序abcd。那么，作为操作系统来讲，我看到a呃，现在它需要做计算，我就把a交给我们CPU去做。a在中间的时候需要等待，需要阻塞，比如说需要等的那个网络的一个输入。这时候呢，它暂时用不着CPU了，怎么办呢诶？把b切换给CPU，让b去做。哎b，等待了让c去做等等，这样呢CPU就不闲着，它速度虽然很快，但我不知道你闲着也能做到充分的利用好这个呢，叫做多进程的并行处理。在这儿就推出来一个概念，什么是进程，什么是线程。

qq程序内部其实它也有好多不同的任务，在并行执行，比如说有的任务在等待着网络的输入，有的任务呢，在刷新UI。有的任务在后台执行save操作，把我的聊天记录给我保存下来，这些个任务。他们之间要执行的时候，哎，实际上也是并行的执行的好，这个时候呢，就产生了线程这个概念。线程是属于一个进程内部的并行执行的这样的不同的路线。线程如果想提升它的效率的话呢，它内容非常的复杂，这里面呢会牵扯到，尤其是网络程序会牵扯到各种各样的，这个网络的编程模型啊和IO结合在一起。

总而言之，从单进程人工切换到多进程的批处理到多进程的并行处理，到一个程序内部不同任务的来回切换，产生了线程的概念啊。然后后面还有进一步的发展，其实那人们开始探索了所谓的绿色线程。就是原来这种多线程呢，是操作系统帮我管理的，那么绿色线程呢，也叫纤程，也叫携程啊。实际上是用户自己管理的，并不是操作系统管理的。

总而言之，线程的历史呢，就是对一部对于性能压榨的历史啊，所以有的大厂呢，他尤其写中间件的这部分人啊，他就是非常喜欢你能透彻的运用你各种各样的手段，多线程也好啊，线程也好，携程也好，你尽你最大的努力，把程序写到最棒，对CPU的利用率最高。这是一个很牛逼的技能

<img src="image/image-20230315195800808.png" alt="image-20230315195800808" style="zoom:67%;" />

大厂喜欢连着问，然后展开

<img src="image/image-20230315200247035.png" alt="image-20230315200247035" style="zoom:67%;" />

到底什么是一个程序？举个小小的例子，`.EXE`这就是一个很普通的WINDOWS底下可以运行的程序。OK，那我们怎么去运行它呢？我们一般来说叫做双击它，它就开始运行。背后执行了什么操作？就是操作系统找到我们这个程序的可执行文件。所谓的一个程序就是一个操作系统可以执行的文件。找到一个文件之后，把它相关的信息load到内存里。也就是说，在内存里头呢就有一个正在运行的QQ点EXE，比如说它是号码一。作为QQ点EXE来说，你可以再双击它一遍诶，它就又放进去一个QQ点EXE。这当然了，这个呢，就是号码二，当然还有号码三四如果你又打开了几个qq.exe的话。OK，所以一个程序呢，是可以在内存里头放好多份儿的，在内存里头的每一份儿都称之为一个进程。

我们操作系统会为每一个进程分配它相关的一些资源，最简单的资源比如说内存空间，当然还有其他资源比如说文件描述符，端口号等等，这些都是它相关的资源。总而言之。程序静静的躺在硬盘上，真正它开始执行的时候，才把它放到内存里。好放到内存之后，哪个程序需要执行，把它放到CPU去执行，这是程序跟进程的概念。一个程序可以有多个进程，当然它可以通过代码来控制它只有一个进程。

把程序放到内存里，变成进程之后，那么就可以给它分配相应的可执行运行的时候所需要的资源了。所以呢，作为进程来讲，它是操作系统进行资源分配的基本单位

![image-20230315200352546](image/image-20230315200352546.png)

其实通俗角度来理解的话呢？基本上一个程序里头不同的执行路径就叫做一个线程。

你会发现我们程序执行的时候一定是执行这句话开始，到if语句里头做个分支，到while语句里做个循环，但是不管你怎么样，你只有一条路径走下来，走到程序的结束。所以说如果你的程序里没有同时都在运行的路径，那就是单线程。但是这个线程呢，一般称之为主线程。我们的main方法所开启的那个线程被称之为主的线程。

那到底什么样的才叫多线程呢？线程的含义当然就是当你启动完一个程序之后，它在中间的时候会产生分支。同时，不同的分支在同时运行。这个分支在等待着程序的输入。这个分支在存数据，这个分支在等待着网络的输入。这几个分支是同一时间段里头都在运行，这个东西叫多线程。

<img src="image/image-20230315201131875.png" alt="image-20230315201131875" style="zoom:67%;" />

我们怎么开始执行这个进程呢？程序是怎么开始执行的呢？真正开始执行的时候，程序是以线程为单位来执行。我们的操作系统会找到我们的主线程，主线程是谁？main方法是吧？开始的这个线程main把它给拎出来，找到没方法的第一句话扔给我们的CPU去执行。找到我们主线程中间开启了其他线程，再来线程之间的来回切换。有ab线程，a线程执行一会儿了，然后让b线程执行一会儿，这就产生了线程的切换。

进程叫做资源分配的基本单位，它是一个静态概念，它就是分配资源的。而线程是在进程的内部是。调度执行的基本单位。线程是一个动态的概念。

作为一个程序来说呢，它有指令有数据啊，程序来说有指令有数据。那么，作为CPU来说呢，它有几个重要的组成单元呃，第一个叫计算单元AVL，还有叫寄存器组用来存储数据的、PC也是一种寄存器，program counter，用来存储我到底执行到哪条指令了。t1线程要运行的时候，把t1的指令和数据放进CPU，然后CPU计算单元对它进行计算，计算好了之后该做输出做输出，该做其他操作的做其他操作。

假如说根据我们操作系统的线程调度的算法，这个线程已经到他的时间了，你该走了。我不能再继续服务你了，我该服务另外一个线程了，在这种情况下该怎么办呢？在我们就把目光集中在这个线程的切换上，现在呢，是t1的线程，它的数据在寄存器里。然后对它来进行计算，那么要换另外一个线程的时候，实际上非常的简单，就是把t1线程的数据和指令。地指令地址了，存好了，存哪去呢？放到我们的缓存cache里面去。你也可以理理解为把它放到内存里，都可以把总而言之把它放到旁边去，放到一个地方，再把另外一个线程t2。它相关的数据，它相关的指令放进来，让CPU继续来做计算。

所以CPU是一个特别傻的东西，他就管算。至于说这条指令和这个数据是属于谁的，属于哪个线程的谁的事儿。这老大操作系统的事情。线程切换当然中间需要经过操作系统的调度过程，那操作系统这个调度呢，也是需要消耗系统资源的。所以线程切换就是这么一个过程，它的专业名词呢叫？context.switch线程上下文切换。

![image-20230315202328797](image/image-20230315202328797.png)

- 单核CPU设定多线程是否有意义?

  有的，因为并不是所有的线程都需要CPU，有的线程可能在阻塞等待网络io。

线程分为cpu密集型和io密集型。

- 工作线程数是不是设置的越大越好?

  线程之间的切换也是需要消耗资源的，肯定不会越大越好。

- 工作线程数(线程池中线程数量)设多少合适?

  根据cpu的核数可以得到一个比较好的速度。但是也不是按照cpu的核数来设置就一定是最好的，因为在你自己机器上跑的东西不只有你的线程。

  下面有公式，但是这么知道W/C是多少？一般来说要根据工具来进行测算。工具一般称之为profiler，profiler对与现在这种场景的简单运用就是去分析我们当前这个程序的性能瓶颈在哪。如果已经部署到远程了，实际运行环境和我的压测的环境不一样了，这时候可以用arthas，

  ![image-20230315204144558](image/image-20230315204144558.png)

### 创建线程的五种方法

1. 继承Thread
2. 实现Runnable接口。利用代理模式，将实现了Runnable接口的类对象传进Thread的构造器中。
3. lamda表达式，本质上就是第二种
4. 线程池
5. 带返回类型的，实现了Callable接口然后由一个泛型来知道返回什么类型，然后利用线程池的submit方法来执行！submit返回的是一个Future类型。
6. 如果不用线程池，自己然后里面自己运行可以带返回值的任务。

```JAVA
public class Code01 {
    static class MyThread extends Thread {
        @Override
        public void run() {
            System.out.println("Hello MyThread!");
        }
    }

    static class MyRun implements Runnable {
        @Override
        public void run() {
            System.out.println("Hello MyRun!");
        }
    }

    static class MyCall implements Callable<String>{
        @Override
        public String call() throws Exception {
            return "6666";
        }
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        System.out.println("========继承=========");
        new MyThread().start();
        Thread.sleep(10);
        System.out.println("========实现Runnable接口=========");
        new Thread(new MyRun()).start();
        Thread.sleep(10);
        //lamda表达式
        System.out.println("========lamda=========");
        new Thread(()->{
            System.out.println("Hello Lambda!");
        }).start();
        Thread.sleep(10);
        //线程池
        System.out.println("=========线程池submit========");
        ExecutorService service= Executors.newCachedThreadPool();
        service.execute(()-> System.out.println("hello!"));
        Thread.sleep(10);
        //有返回值类型
        System.out.println("=========线程池有返回值类型========");
        Future<String> f = service.submit(new MyCall());
        System.out.println(f.get());
        service.shutdown();
        Thread.sleep(10);
        //FutureTask
        System.out.println("=========FutureTask========");
        FutureTask<String> futureTask=new FutureTask<>(new MyCall());
        new Thread(futureTask).start();
        System.out.println(futureTask.get());
        Thread.sleep(10);
    }
}
```

### 线程的状态

Runnable分为READY和RUNNING，READY代表可以被线程调度器选中执行了，RINNING代表已经被选中了，在执行了。`YIELD`方法就是在这两种状态之间的切换。

![image-20230402181412851](image/image-20230402181412851.png)

READY就是我可以运行了在等CPU运行我，RUNNING就是CPU正在运行我。

synchronized----正在等待某一把锁，但是我还没有竞争到这把锁，我正在抢这把锁呢，那么这时候，我是被blocked，是被阻塞的状态。

waiting的意思是我并没有进入说阻塞这种状态，不是说我进入阻塞队列，而是说我进入一个忙等待。等待锁这个过程，除了synchronized的这种状态叫blocked之外，其他的等锁的过程都叫做waiting。

![image-20230402182558992](image/image-20230402182558992.png)

```JAVA
public static void main(String[] args) throws Exception {

        Thread t1=new Thread(()->{
            System.out.println("2:"+Thread.currentThread().getState());//START了才会执行里面的代码
            System.out.println("t1 is working ...");
            SleepHelper.sleep(1);//try-catch麻烦自己写一个
        });
        System.out.println("1:"+t1.getState());
        t1.start();//将t1线程开启，start之前都是new状态，start之后要么是READY要么是RUNNING，也就是RUNNABLE
        t1.join();//等待t1线程结束
        System.out.println("3:"+t1.getState());//t1线程结束

        System.out.println("=====================================");

        Thread t2=new Thread(()->{
            LockSupport.park();//等着被别人叫醒---waiting
            System.out.println("t2 is working");
            SleepHelper.sleep(3);
        });
        t2.start();
        SleepHelper.sleep(1);
        System.out.println("4:"+t2.getState());//因为park了，所以此时是WAITING
        LockSupport.unpark(t2);//叫醒t2
        SleepHelper.sleep(1);//睡一秒确定t2已经被叫醒了
        System.out.println("5:"+t2.getState());//t2往下执行到sleep---TIMED_WAITING

        System.out.println("=====================================");

        final Object o=new Object();//资源
        Thread t3=new Thread(()->{
            synchronized (o){
                System.out.println("t3 得到了锁 o");
            }
        });

        new Thread(()->{//定义为t3之后直接启动一个线程先去把资源o抢了
            synchronized (o){
                System.out.println("另一个线程 得到了锁 o");
                SleepHelper.sleep(3);
            }
        }).start();

        SleepHelper.sleep(1);
        t3.start();//另外一线线程拿着资源要占3s，此时t3被阻塞了，BLOCKED
        SleepHelper.sleep(1);
        System.out.println("6:"+t3.getState());//此时另外一个线程还没释放资源，还是阻塞
        SleepHelper.sleep(2);//主线程睡这两秒的过程中，另外一个线程释放资源了，t3得到了资源，开始working

        System.out.println("=====================================");

        final Lock lock = new ReentrantLock();//用的JUC的锁---cas实现---是一种忙等待，不是BLOCKED
        Thread t4=new Thread(()->{
            lock.lock();//申请获得这把锁
            System.out.println("t4 得到了锁");
            System.out.println("t4 is working");
            SleepHelper.sleep(1);
            lock.unlock();//释放锁
        });

        new Thread(()->{//t4定义完成之后直接启动一个线程先去把锁抢了
            lock.lock();//申请获得这把锁
            System.out.println("另外一个线程 得到了锁");
            SleepHelper.sleep(3);//拿着锁3秒
            lock.unlock();//释放锁
        }).start();

        SleepHelper.sleep(1);//此时另外那个线程差不多还有2s才释放锁
        t4.start();//另外一个线程还有2s释放锁，所以t4还有2s左右才能开始working
        SleepHelper.sleep(1);//还1s释放锁
        System.out.println("7:"+t4.getState());//还没抢到锁，忙等
        SleepHelper.sleep(3);//睡完肯定抢到了并且工作结束了

        System.out.println("=====================================");

        Thread t5=new Thread(()->{
            LockSupport.park();//等着被叫醒
            System.out.println("t5 is working");
            SleepHelper.sleep(1);
        });
        t5.start();
        SleepHelper.sleep(1);
        System.out.println("8:"+t5.getState());//还没被叫醒---WAITING
        LockSupport.unpark(t5);//叫醒了
        SleepHelper.sleep(2);

    }
```

### 线程的“打断”

和线程打断有关的三个方法。

`thread.interrupt()`并不是直接就把这个线程打断了，而是设置这个线程的中断标志位，至于后面要怎么处理，是由这个线程自己说了算。

`thread.isInterrupted()`就是字面意思，依然有人可以设置中断标志位，我就可以查一下是否它被设置过

`Thread.interrupted()`第三个方法和第二个方法要区别开，因为第三个方法是一个静态方法，这个方法对当前线程查询是否被打断过，重置打断标志

<img src="image/image-20230402193236851.png" alt="image-20230402193236851" style="zoom:67%;" />

看一下第一个方法和第二个方法

```JAVA
public static void main(String[] args) {
        Thread t=new Thread(()->{
            int i=0;
            while (true){
                if (i==0){
                    System.out.println("Thread is "+(Thread.currentThread().isInterrupted()?"":"not")+" interrupted!");
                    i++;
                }
                if (Thread.currentThread().isInterrupted()){
                    System.out.println("Thread is "+(Thread.currentThread().isInterrupted()?"":"not")+" interrupted!");
                    break;//只要有人设置过标志位了，那么就结束线程，这也是比较优雅的结束线程的方法。
                }
            }
        });
        t.start();//上来肯定还没有被设置过
        SleepHelper.sleep(2);//两秒
        t.interrupt();//打断它
    }
```

输出：

```JAVA
Thread is not interrupted!
Thread is  interrupted!
```

看第三个方法

```JAVA
public static void main(String[] args) {
        Thread t=new Thread(()->{
            int i=0;
            while (true){
                if (i==0){
                    System.out.println("Thread is "+(Thread.interrupted()?"":"not")+" interrupted!");
                    i++;
                }
                if (Thread.interrupted()){//这里if判断的时候查询的时候是true，但是进入if之后已经重新设置为false了
                    System.out.println("Thread is "+(Thread.interrupted()?"":"not")+" interrupted!");
                    break;
                }
            }
        });
        t.start();//上来肯定还没有被设置过
        SleepHelper.sleep(2);//两秒
        t.interrupt();//打断它
        System.out.println("Main:"+t.interrupted());//尽管这里是t，由于这个方法是静态的，永远都是访问的当前线程，此时也就是main
    }
```

输出：

```
Thread is not interrupted!
Thread is not interrupted!
Main:false
```

再来看看interrupt的sleep的配合使用。当你对一个线程 thread 调用sleep  wait   join  这样的方法的时候，你是可以对 thread 这样的线程设置标志位的。一旦在 thread，sleep、wait、join的时候你对它设置了标志位，那么这几个方法就会抛异常`InterrptedExcepetion`！你下一步怎么处理catch这个异常之后，你要不要catch？catch完之后怎么处理？其实主动权还是交给了线程本身。

比方说7×24小时365天不间断运行的这种服务器程序。在你服务器程序的这个循环里头如果有sleep方法（当然一般不建议有），如果有wait方法（这个这个倒是有可能），如果有什么join（也很少用），总而言之，像这种的，你要想它正确，你要想用interrupt的方法让它停止的话，你这个时候必须得catch住interrupted异常，然后对这个异常做出正确的响应。言而总之，这个灵活度是交给写程序员的，并没有一个固定的处理过程。

有同学就容易混淆，你看他都已经打断了、都已经抛异常了，它是不是就该结束了？catch了这个异常之后怎么处理是你自己的事情。

可以看到catch里面处理的时候，这个标志位是false。一旦抛出interrupted exception的异常之后，默认的情况下。JAVA会自动的帮你把那个标志位给复位。

```JAVA
public static void main(String[] args) {
        Thread t=new Thread(()->{
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                System.out.println("Thread is interrupted!");
                System.out.println(Thread.currentThread().isInterrupted());
            }
        });
        t.start();
        SleepHelper.sleep(1);
        t.interrupt();
    }
```

输出：

```
Thread is interrupted!
false
```

还有就是wait，和上面类似，也是有在catch里面自己处理中断异常

```java
private static Object o=new Object();
public static void main(String[] args) {
    Thread t=new Thread(()->{
       synchronized (o){
           try {
               o.wait();
           } catch (InterruptedException e) {
               System.out.println("Thread is interrupted!");
               System.out.println(Thread.currentThread().isInterrupted());
           }
       }
    });
    t.start();
    SleepHelper.sleep(1);
    t.interrupt();
}
```

输出：

```
Thread is interrupted!
false
```

我们来聊一个很严重的小问题，就是我这个设标志位这件事儿，是不是能够把一个正在争抢锁、正在竞争锁的`synchronized`这个状态给它打断？它会不会抛异常？结论：这是不可能的。强调一遍，这个东西叫设标志位，而并不是把线程给打折腿儿。你设了个标志位，那我该抢锁还是要抢锁，它不会理会。

```JAVA
    private static Object o=new Object();
    public static void main(String[] args) {
        Thread t1=new Thread(()->{
           synchronized (o){
               System.out.println("t1 is working");
               try {
                   Thread.sleep(5000);
               } catch (InterruptedException e) {
                   System.out.println("Thread is interrupted!");
                   System.out.println(Thread.currentThread().isInterrupted());
               }
           }
        });
        t1.start();
        SleepHelper.sleep(1);//t1 remain 4s
        Thread t2=new Thread(()->{
            synchronized (o){
                System.out.println("t2 is working");
                System.out.println(Thread.currentThread().isInterrupted());
            }
        });
        t2.start();
        SleepHelper.sleep(1);//t1 remain 3s
        t2.interrupt();//不会打断抢锁的动作，但是中断位确实被设置为true了
        SleepHelper.sleep(1);//t1 remain 2s
        t1.interrupt();//t1抢到锁，是可以被中断的，中断之后立马释放资源，t2立马抢到资源开始工作
        //这里t2线程开始工作....
    }
```

输出：

```
t1 is working
Thread is interrupted!
false
t2 is working
true
```

上面讲过interrupt是不可能打断synchronized这个抢锁过程的，那interrupt能不能够打断juc里面的reentrant lock这种新新型的锁？抢锁的过程是影响不到的，也就是t2会一直在lock()那等待，你设置了标志位也是等进入到了working的过程中才会触发中断。

```java
private static ReentrantLock lock=new ReentrantLock();
public static void main(String[] args) {
    Thread t1=new Thread(()->{
        lock.lock();//抢锁
        try {
            System.out.println("t1 is working");
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            System.out.println("Thread t1 is interrupted!");
            System.out.println(Thread.currentThread().isInterrupted());
        } finally {
            lock.unlock();//释放锁
        }
    });
    t1.start();
    SleepHelper.sleep(1);//t1 remain 4s
    Thread t2=new Thread(()->{
        lock.lock();
        try {
            System.out.println("t2 is working");
            Thread.sleep(200);
        } catch (InterruptedException e) {
            System.out.println("Thread t2 is interrupted!");
            System.out.println(Thread.currentThread().isInterrupted());
        } finally {
            lock.unlock();//释放锁
        }
        System.out.println("t2 is finished");
    });
    t2.start();
    SleepHelper.sleep(1);//t1 remain 3s
    t2.interrupt();//不会打断抢锁的动作，但是中断位确实被设置为true了,3s后刚一抢到里面进入异常处理了
    SleepHelper.sleep(1);//t1 remain 2s
    t1.interrupt();//t1抢到锁，是可以被中断的，中断之后立马释放资源，t2立马抢到资源开始工作，t2提前两秒
    //这里t2线程开始工作....
}
```

输出：

```
t1 is working
Thread t1 is interrupted!
false
t2 is working
Thread t2 is interrupted!
false
t2 is finished
```

如果我就想打断抢锁的过程。

```java
private static ReentrantLock lock=new ReentrantLock();
    public static void main(String[] args) {
        Thread t1=new Thread(()->{
            lock.lock();//抢锁
            try {
                System.out.println("t1 is working");
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                System.out.println("Thread t1 is interrupted!");
                System.out.println(Thread.currentThread().isInterrupted());
            } finally {
                lock.unlock();//释放锁
                System.out.println("t1 is finished");
            }
        });
        t1.start();
        SleepHelper.sleep(1);//t1 remain 4s
        Thread t2=new Thread(()->{
            try {
                lock.lockInterruptibly();
                System.out.println("t2 is working");
            } catch (InterruptedException e) {
                System.out.println("Thread t2 is interrupted!");
                System.out.println(Thread.currentThread().isInterrupted());
            } finally {
//                if (lock.isLocked()) lock.unlock();//报错
            }
            System.out.println("t2 is finished");
        });
        t2.start();
        SleepHelper.sleep(1);//t1 remain 3s
        t2.interrupt();//不会打断抢锁的动作，但是中断位确实被设置为true了,3s后刚一抢到里面进入异常处理了
        SleepHelper.sleep(1);//t1 remain 2s
    }
```

输出：

```
t1 is working
Thread t2 is interrupted!
false
t2 is finished
t1 is finished
```

### 如何优雅的结束一个线程

你让一个线程自然而然运行结束，这是最优雅的方式，但是像这种方式的话，实际当中有可能是你你做不到的，因为有些线程就是一个死循环。7×24小时365天不间断运行的服务器中间出问题了，你想把服务器给中断掉，好多人都登录在上面，自己的中间的状态信息全都在这个服务器上，你不能随随便便把它给打断。所以这个时候你怎么优雅的把这个线程给它终止掉呢？还能够尽量的不丢失中间的这些状态呢？

用stop来终止已经被废弃了。stop方法非常的粗暴，就是你正在那儿跑，他二话不说，直接把你打腿儿打折，不让你往前跑了。为什么不建议呢？主要就是因为它容易产生这种数据不一致的问题。

stop方法会干一件事儿。它会比如说啊，你现在在这里的时候，你持有一把锁，或者你持有好几把锁，随便你，它会二话不说，释放所有的锁，并且不会做善后的工作。给某一把锁上锁之后，你本来是呢要完成某一种数据的一致性，你要把这个a这个数据改成3，b这个数据改成4，这两要互相配合，a和b结为夫妻。结果呢，老公给老婆设好了a=3，还没来得及设b=4的时候就被stop方法给干掉了，非常容易产生数据不一致的问题。

```JAVA
public static void main(String[] args) {
    Thread t=new Thread(()->{
       while (true){
           System.out.println("working ...");
           SleepHelper.sleep(1);
       }
    });
    t.start();
    SleepHelper.sleep(5);
    t.stop();
}
```

输出：

```
working ...
working ...
working ...
working ...
working ...
```

和stop方法一样还有两个也是被废弃的方法，一个是suspend，一个是resume。suspend是暂停的意思，resume是恢复执行的意思。

为什么这两个方法也废弃了？这个原因呢，跟stop非常的类似。你让它暂停，万一它暂停的时候正在持有一把锁，然后这个锁是不会被释放的，这锁要是不会释放的话，你什么时候让它重新启动啊？万一你忘了让它重新继续这把锁，可就永远不会被释放了。所以这俩方法也依然特别容易产生这种数据不一致的问题，或者说容易产生死锁的问题。

```java
public static void main(String[] args) {
    Thread t=new Thread(()->{
       while (true){
           System.out.println("working ...");
           SleepHelper.sleep(1);
       }
    });
    t.start();
    SleepHelper.sleep(5);//5s 之后把t暂停
    t.suspend();
    System.out.println("suspend");
    SleepHelper.sleep(3);//3s 之后让t继续
    t.resume();
    SleepHelper.sleep(3);//stop结束掉
    t.stop();
}
```

输出：

```
working ...
working ...
working ...
working ...
working ...
suspend
working ...
working ...
working ...
```

那么如何优雅的结束呢？volatile这种方式，你会发现运行两次两个数字不一样。用这种方式是可以让线程结束，但是你很难精确的控制，说我循环了多少次。所以volatile其实也算是相对优雅的一种让线程结束的方式，只要你不依赖于while循环里面的中间有状态，比如那个 i，我非得加到被二整除才能结束，不被二整除不能结束等等，只要你不依赖于这玩意儿，那么volatile还是可以起到它的作用的。

当然volatile也有它的局限性，你需要意识到这一点。它是时间上是很难控制的，不能控制时间的话，比如说，我们有一个生产者消费者的问题，然后我这个有一个能装十个元素的容器，我装到第四个的时候，我必须得停止，你用volatile让它停止这个就不太现实。因为你要用volatile让它停止的话，在判断这个volatile变量的时候，下面有可能由于时间上不固定，所以有可能在循环的过程之中，你可能已经多加了两个进去了。

还有一种情况就是，如果我在这个循环里头有wait、receive、accept等等这方面的一些操作的时候。wait的话它就会阻塞在那里，虽然你这个running设为false了，但是由于中间阻塞了之后它不能回到下一次循环，所以它也结束不了。

相对来说，只要是你不依赖于中间状态，比方说上传个文件，你说多传一点儿数据，少传一点儿数据，让它停止这个是无所谓的。所以volatile在特定的场景之下有它的作用，而且用起来比较方便。

```java
public class Code03 {//volatile
    private static volatile boolean running =true;
    public static void main(String[] args) {
        Thread t=new Thread(()->{
            long i=0L;
            while (running) {
                i++;
            }
            System.out.println("Thread t finished and i = "+i);
        });
        t.start();
        SleepHelper.sleep(1);
        running=false;
    }
}
```

输出：

```
Thread t finished and i = 3304041449     ---- 第一次
Thread t finished and i = 3388427933     ---- 第二次
```

还有另外一种方法就是使用我们的interrupt设定标志位。与此同时，在我们的业务逻辑里面，到合适的时间点，我们要检查这个标记位是不是被设置了，如果被设置了的话我就退出就可以了。

和volatile非常类似，中断标志位也是一个标志位啊。只不过中断标志位这个是线程自带的标志位，而volatile是我们自己手工设置了一个标志位。哪种更加的优雅一些呢？interrupt会更加的优雅一些。因为如果是volatile中间有一些sleep，wait，这样的方法的时候，你是让它停不了的，你不能够跳到下一次循环让它去读那个running的标志位。但是，如果是interrupt的话，你只要在sleep wait里面处理interrupted exception，其实也可以正确的结束这个线程。

当然interrupt也有它自己的一些不太合适的地方，有些场景也不合适。和volatile一样，都无法控制中间的一些状态。必须得你自己的这个业务线程--生产者线程和我们外面要执行打断生产者线程的这个线程要做配合才行。

还有一些其他的方法可以结束一个线程，但是大同小异。有一些方法，是需要你内部线程做一些定时的检查，比如说我每隔多长时间检查一个标志位。其实呢，也是标志位。每经过一次循环检查一次标志位，实际上就是现在的这个interrupted。总而言之，如果说你不依赖于中间的那种精确的次数或者精确的时间，interrupt或者volatile flag 都好使。

```java
public class Code04 {//中断标志位
    public static void main(String[] args) {
        Thread t=new Thread(()->{
            while (!Thread.interrupted()){

            }
            System.out.println("Thread t finished");
        });
        t.start();
        SleepHelper.sleep(3);
        t.interrupt();
    }
}
```

输出：

```
Thread t finished
```

当然，要想精确的控制在某个点上或者循环多少次，或者某个值到那个位置之后，我想让它停止，就必须让你的那个业务线程跟外面的你要结束它的这个线程相配合，这时候就要用到锁才能做到精确的控制



## 并发编程的三大特性

面试中的重中之重！

这三大特性分别是什么呢？第一个叫可见性visibility。第二个叫有序性，第三个叫原子性。这里面最复杂的实际上是原子性。当然，其实哪个都不太简单，牵扯到一些底层的内容。

### 可见性

运行下面代码。理想的执行状态呢是最开始的时候呢running为true，执行m方法打印m start，在while里面运行了大概一秒钟以后，running设为false，应该是打印m finished的。

但是运行了之后发现没有打印m finished。这里头就牵扯到了线程的可见性问题。

```JAVA
public class Code01 {//可见性
    private static boolean running=true;
//    private static volatile boolean running=true;
    private static void m(){
        System.out.println("m start");
        while (running){

        }
        System.out.println("m finished");
    }

    public static void main(String[] args) {
        new Thread(Code01::m,"t1").start();
        SleepHelper.sleep(1);
        running=false;
    }
}
```

输出：只有一行m start

```
m start
```

running一定是位于我们的主内存里面，然后有两个线程都会用到这个running。第一个线程t1会用到这个running，他会去读这个running，读的是实际上是它的拷贝。说每个线程在运行的时候都会把这个数据从内存里面读出一份儿来，放在线程本地。线程本地这里指的是线程的缓存，而不是ThreadLocal。缓存这个值，它不会主动的去内存里面重新再读一遍，while循环里面一直是true。

另外一个线程是我们的主线程，main线程，在main线程里面隔了一秒钟之后，它把它自己本地缓存的这个running改成了false，改的是拷贝，和我的第一个线程一点关系都没有。

一个线程修改值之后，另外一个线程是不是能见到最新被修改的值，这就是线程的可见性。默认的情况下呢，一个线程改了之后呢，另外一个线程是看不见的

![image-20230403150742247](image/image-20230403150742247.png)

如何让线程之间相互看得见修改的值？只需要加上一个`volatile`修饰符。

```GPT
在Java中，volatile是一种轻量级的同步机制，用于保证变量的可见性和禁止指令重排。当一个变量被声明为volatile后，对它的写入操作会立即刷新到主内存中，而读取操作也会从主内存中读取最新的值。

底层实现方面，volatile的实现依赖于JVM的内存模型和硬件架构。JVM会根据硬件架构的特点来生成适当的机器指令，以实现volatile的语义。

在x86架构的处理器上，volatile变量的读写操作会通过使用lock前缀指令来实现。这个指令会将变量的修改立即刷新到主内存中，以保证变量的可见性。同时，它也会禁止处理器对指令进行重排，以保证指令的执行顺序与代码的顺序一致。

需要注意的是，volatile并不保证原子性，也就是说，如果对一个volatile变量进行复合操作（例如i++），则它仍然可能出现线程安全问题。如果需要保证原子性，可以使用java.util.concurrent.atomic包中提供的原子类。

总的来说，volatile的底层实现涉及到JVM和硬件架构，是非常复杂的。因此，在使用volatile时，我们不需要了解具体的实现细节，只需要知道它提供了一种简单、轻量级的同步机制，能够保证变量的可见性和禁止指令重排即可。
```

volatile的第一个作用，叫保持线程的可见性。volatile在这里是起的什么作用呢？就是volatile所修饰的这块儿内存，对于他的任何的修改。另外一个线程立马可见可见，可见的意思是说，对volatile修饰的这块内存，我每次去读的话都从主内存里读一遍。while循环每次都要用到这个值，那么每次我都去主内存里读一遍。

```JAVA
public class Code02 {//可见性
//    private static boolean running=true;
    private static volatile boolean running=true;
    private static void m(){
        System.out.println("m start");
        while (running){

        }
        System.out.println("m finished");
    }

    public static void main(String[] args) {
        new Thread(Code02::m,"t1").start();
        SleepHelper.sleep(1);
        running=false;
    }
}
```

输出：这时候就输出了finish了

```
m start
m finished
```

我们在while里面放了一个println，发现运行之后没有加volatile也成功停止运行了，也就是在运行的时候线程之间保持了可见性机制了。因为这个里面呢，触发了这个可见性机制。

因为prinln函数里面有一个synchronized，synchronized也是可以保持可见性的。在某些语句执行的情况下，它是可以触发本地的缓存和我们主内存之间的数据，进行一个刷新和同步。

那我以后在每个里面都加一个println行不行？别这样，你每加一个println不就上了把锁，相当于那你效率不就变低了。所以我们该用volatile还是要用volatile。

```JAVA
public class Code03 {//可见性
    private static  boolean running=true;
    private static void m(){
        System.out.println("m start");
        while (running){
            System.out.println("hello!");
        }
        System.out.println("m finished");
    }

    public static void main(String[] args) {
        new Thread(Code03::m,"t1").start();
        SleepHelper.sleep(1);
        running=false;
    }
}
```

输出：

```
hello!
hello!
hello!
hello!
m finished
```

volatile 修饰引用类型只能保证引用本身的可见性，不能保证内部字段的可见性。并不会停止，因为内存中有一个对象r，在线程t和线程main中都有自己的拷贝，只有a这个引用是可见的。所以在main中把自己拷贝的那个r对象改成了false不会影响t线程。

在下面代码中，a对象被声明为volatile，因此对它的修改会立即刷新到主内存中，保证了变量的可见性。但是，对于A类中的running变量，并没有使用volatile或者其他的同步手段，因此，在主线程中修改running变量的值并不能保证在新线程中立即可见。

具体来说，当线程t1启动时，它将running变量的值读入到自己的工作内存中。在此后的循环中，t1只会使用自己工作内存中的running变量，不会重新从主内存中读取该变量的值。因此，即使主线程将running变量的值修改为false，t1也可能不会立即发现这个变化，导致t1无法及时停止循环。

为了解决这个问题，我们需要使用同步手段，如synchronized或者volatile，来保证running变量的可见性。如果我们将A类中的running变量声明为volatile，那么当主线程将running变量的值修改为false时，这个变化会立即刷新到主内存中，从而让t1线程立即看到这个变化。

你想让它可见就在running的前面加volatile ，不要在引用类型前面加。

即使在后面你`a=new A(false);`也无法退出循环。在主线程中将a变量设置为新的A对象之后，t1线程仍然在执行旧的A对象的m方法，因此它读取的仍然是旧的A对象的running变量的值。因此，即使主线程将新的A对象的running变量设置为false，t1线程仍然在执行旧的A对象的m方法，从而导致循环无法及时退出。

```JAVA
    private static class A{
        boolean running;
        void m(){
            while (running){
            }
        }

        public A(boolean running) {
            this.running = running;
        }
    }

    private static volatile A a=new A(true);
    public static void main(String[] args) {
        new Thread(a::m,"t1").start();
        SleepHelper.sleep(1);
        System.out.println("过了1s");
        a.running=false;
    }
```

输出：无法退出

缓存的速度很快。

![image-20230403161606150](image/image-20230403161606150.png)

我们平时所说的线程的这个缓存啊，可见性来说，其实指的是这些缓存L1、L2、L3，并不是ThreadLocal。

为了让效率更高，然后我们读东西的时候，往往是按照一块儿一块儿的读，而不是你要一个int我就只读一个int，它是一读就读一个block。原理是程序的局部性原理，相邻的东西更容易读到，这是空间局部性原理。时间局部性原理就是如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。

这一块数据到底有多大呢？叫做一个缓存行。专业名词叫catch line。

![image-20230403161655199](image/image-20230403161655199.png)

在我们内存里面的任何的数据的组织都是按照一行一行来组织，或者叫一块一块来组织。这个大小呢是64个字节，Intel x86和x86-64架构中，缓存行的大小为64字节。

当多个线程同时访问同一块内存时，它们会将这些内存数据加载到自己的CPU缓存中，从而提高访问速度。缓存行的大小对于多线程编程的性能有很大的影响。当多个线程访问同一块内存时，如果它们同时访问的数据位于同一个缓存行中，那么它们就会发生缓存行竞争，从而导致性能下降。为了避免缓存行竞争，可以采用缓存行填充等技术，将不同的数据项分别放置在不同的缓存行中，从而减少不同线程之间的竞争。

为了避免缓存行竞争，可以采用缓存行填充等技术，将不同的数据项分别放置在不同的缓存行中，从而减少不同线程之间的竞争。另外，也可以采用锁、原子操作等技术来保证对共享数据的访问顺序，从而避免缓存行竞争。

![image-20230403162535465](image/image-20230403162535465.png)

当多个CPU缓存同时修改同一个缓存行中的数据时，它们会竞争同一条缓存总线来获取对缓存行的独占访问权。在这个过程中，如果一个线程修改了缓存行中的数据，它需要将这些修改同步到主内存中，以保证其他线程能够读取到最新的数据。

在多核CPU中，每个核心都有自己的L1和L2缓存，不同核心之间的缓存是独立的。当多个线程同时修改同一个缓存行中的数据时，它们会通过共享的缓存总线来协调数据的同步和访问顺序，以保证数据的一致性。如果多个线程之间的竞争过于激烈，就会导致缓存行的频繁切换和竞争，从而降低程序的性能。

在T类中，可以看到注释掉的一段代码，这是为了测试缓存行对性能的影响。当取消注释时，x变量会被分割成多个long类型的变量，从而让它们在不同的缓存行上，进一步展示缓存行对性能的影响。

缓存的一致性协议跟volatile没有什么关系。

```JAVA
public class Code06 {//缓存行
    public static long COUNT=30_0000_0000L;

    private static class T{
       // private long x1,x2,x3,x4,x5,x6,x7,x8;
        public long x=0L;

       // private long x9,x10,x11,x12,x13,x14,x15,x16;

    }

    public static T[] arr=new T[2];

    static {
        arr[0]=new T();
        arr[1]=new T();
    }

    public static void main(String[] args) throws InterruptedException {//357
        CountDownLatch latch=new CountDownLatch(2);

        Thread t1=new Thread(()->{//不断修改arr[0]
            for (int i = 0; i < COUNT; i++) {
                arr[0].x=i;
            }
            latch.countDown();
        });

        Thread t2=new Thread(()->{
            for (int i = 0; i < COUNT; i++) {//不断修改arr[1]
                arr[1].x=i;
            }
            latch.countDown();
        });

        final long start=System.nanoTime();
        t1.start();
        t2.start();
        latch.await();
        System.out.println((System.nanoTime()-start)/100_0000);

    }
```

真的有人会这么写程序吗？是真的。jdk1.7的源码，jdk大神在他的linked blocking queue类里面就运用过这种写法。带你认识另外一个特别的、也是大神级别的一个开源框架。这个框架呢，就是大名鼎鼎的disruptor。翻译过来叫闪电，速度特别快。这个可以说是目前为止单机效率最高的一个mq单机版的。mq就是装消息用的，一般有一个缓存，一般我们聊缓存的时候，都是指的是一个字节数组啊，头指针尾指针等等的。

但是它这个缓存呢，是一个叫做环形的缓冲区，ring buffer。里面通过后面我们要讲的cas以及现在我们讲的这个catchline padding就是缓存行的对齐，通过这个概念大大的提高了效率。

![image-20230403205835123](image/image-20230403205835123.png)

<img src="image/image-20230403205932285.png" alt="image-20230403205932285" style="zoom: 50%;" />

要是万一哪天缓存行变成128个字节了，变成256个字节了。有没有一种机制说能将来缓存后要变化了，我能让它呃程序不用变。可能是出于这种考虑。oracle在jdk1.8的时候提供了一个注解。这个注解保证被它标注的数据不会和其他数据位于同一行。`CONTENTED`，要用这个注解1.9版本以上会报错。

发生这种诡异现象的主要的问题呢是出在两个CPU之间，缓存行要保持数据一致的话，它们有一种机制，这边改了，另外一边会得到通知，那么这种机制我们称之为缓存一致性协议。缓存一致性协议这个概念不要和MESI Cache这个概念混了。不同的类型的CPU，它们所采用的这种缓存一致性的协议是不一样的，所谓的MESI其实只是缓存一致性协议中的一种。MESI最有名，因为上是Intel设计的。

所谓的MESI实际上指的是缓存行的四种状态的首写。volatile和mesi混在一起讲是不对的，volatile底层也不是MESI实现的。

![image-20230403212650680](image/image-20230403212650680.png)

为什么缓存行设计为64字节？这个是一个工业实践之中得出的最佳实践

<img src="image/image-20230403212940848.png" alt="image-20230403212940848" style="zoom:67%;" />

### 有序性

1线程的两个赋值语句和2线程的两个赋值语句会排列组合，也就是谁先谁后是不一定的。并且这里出现了x=0且y=0的情况，这是在线程1内部和线程2内部的赋值语句执行顺序都乱了才产生的。具体就是在线程1中先执行了x=b再执行a=1，然后在线程2中先执行了y=a再执行了b=1。所以这就是线程内部的语句可能会产生乱序，由于就是cpu把不会相互干扰的指令可能会调换顺序以提高效率。

```JAVA
public class Code01_Disorder {
    private static int a=0,b=0;
    private static int x=0,y=0;

    public static void main(String[] args) throws InterruptedException {
        for (int i = 0; i < Long.MAX_VALUE; i++) {
            x=0;
            y=0;
            a=0;
            b=0;

            CountDownLatch latch=new CountDownLatch(2);
            Thread one=new Thread(()->{
                a=1;
                x=b;
                latch.countDown();
            });
            Thread other=new Thread(()->{
                b=1;
                y=a;
                latch.countDown();
            });
            one.start();
            other.start();
            latch.await();
            if (x==0&&y==0){
                System.err.println("第"+i+"次x=0、y=0");
                break;
            }

        }

    }
}
```

输出：

```
第4845次x=0、y=0
```

cpu为了提高效率不会傻傻的顺序执行，如果前面的指令需要去内存读数据，后面的指令是把寄存器数值+1，并且前面的取数据操作对后面的操作不会产生影响，此时cpu就可能把后面的指令先执行。从底层来讲呢，CPU是为了提高效率进行的一个优化机制，所以才有乱序这件事情存在。前后两条语句没有依赖关系，这两条语句有可能会换顺序，不影响单线程的最终一致性。

乱序存在实际上不影响单线程的最终一致性，`AS-IF-SERIAL`，也就是你好像是一步一步执行---前提是单线程。所以我们上面代码中有下面两句，这两句的执行肯定没有依赖关系，所以有可能换顺序。虽然说在单线程里这样的乱序没影响，不过要是在多线程里产生乱序的话，它的影响还是非常非常严重的。

                a=1;
                x=b;

下面程序的目的是演示的第一个问题是可见性问题，即在多线程环境下，一个线程对某个变量的更改，是否可以被另一个线程看到。我们肯定期望的是线程最后输出42，但是如果主线程运行比较慢，还没有把ready改为true这个ready就被那个线程拿去用了，那么就可能无法退出循环，因为即使后面主线程把ready改为了true，由于缺乏可见性保障机制，不能保证那个线程看得到。

```GPT
当一个线程调用Thread.yield()方法时，它会让出自己的CPU时间片，让其他具有相同或更高优先级的线程先执行，但并不保证其他线程一定会被执行。在大多数情况下，Thread.yield()方法的使用并不是必需的，因为操作系统会根据自己的调度策略自动分配CPU时间片。但在某些情况下，使用Thread.yield()方法可能会对性能产生积极的影响。

t.join() 是一个线程的方法，它的作用是让当前线程等待指定的线程 t 终止后再继续执行。在本程序中，主线程通过调用 t.join() 来等待 ReaderThread 线程执行完毕。

具体来说，当主线程调用 t.join() 方法时，它会阻塞自己，等待 ReaderThread 线程执行完毕后再继续执行。如果 ReaderThread 线程已经执行完毕，那么主线程会立即继续执行。如果 ReaderThread 线程还没有执行完毕，那么主线程会一直阻塞，直到 ReaderThread 线程执行完毕后才会继续执行。

在本程序中，主线程需要等待 ReaderThread 线程执行完毕后才能结束，否则程序会在 ReaderThread 线程还未执行完毕的情况下就结束，导致 ReaderThread 线程无法完成输出操作。因此，主线程调用 t.join() 方法来确保 ReaderThread 线程执行完毕后再继续执行。
```

第二个问题是有序性问题。ready和number的赋值顺序可能会不一样，导致线程输出number=0。

```java
public class Code02_NoVisibility {
    private static boolean ready=false;
    private static int number;

    private static class ReaderThread extends Thread{
        @Override
        public void run() {
            while(!ready){
                Thread.yield();//变为就绪态，让出时间片
            }
            System.out.println(number);
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Thread t=new ReaderThread();
        t.start();
        number=42;
        ready=true;
        t.join();//主线程等待t线程执行结束
    }
}
```

创建一个很简单的对象，下面是对应的汇编代码。new一个对象的步骤，第一步申请内存，跳过dup，第二步是就是调用构造方法，astore是建立关联，和我们要建立的t建立关联。JAVA是这样的，当我们申请一块儿内存new出一个对象来的时候，它里面的成员变量都会有一个默认的值，而int类型的默认的值是零。所以当我们执行完第一条指令的时候，new完了之后m的值默认值它是零，这是一个对象的半初始化状态。

```
如果是我们是写c的，写C加加的，当我们NEW一个对象出来的时候，或者分配一块内存的时候，这里面这里面的值到底是几其实是跟这个内存原来的那个值，也就是上一个程序留下来的这块值有关系
```

当调用第二条指令`invokespecial #3 <T.<init>>`的时候m才会变成8。

最后这个astore的意思是建立关联。小t和我们的new出来这个对象建立关联，其实就是和this建立关联，通过小t我们可以找到它了

<img src="image/image-20230404163321745.png" alt="image-20230404163321745" style="zoom:67%;" />

明白了对象的半初始化状态，明白了指令的重排序之后，我们来看这个小程序。去运行一下，你会发现确实输出了888，但是这里有可能有问题。即在对象未完成构造之前，就把this对象传递给了另一个线程，从而导致了"this逃逸"问题。在构造器执行过程中，对象的状态还没有完全初始化完成，就已经被另一个线程所使用，从而导致程序出现异常或者错误的行为。

由于有这个，这次溢出现象的存在，所以我们一般在构造方法里面去new线程然后让它启动。单独写一个方法启动去，也就是确保构造方法完成之后再调用start。

```JAVA
public class Code03_ThisEscape {
    private int num=888;

    public Code03_ThisEscape() {//构造器
        new Thread(()->{
            System.out.println(num);
        }).start();
    }

    public static void main(String[] args) throws IOException {
        new Code03_ThisEscape();
        System.in.read();//让主线程阻塞一下，确保输出完毕
    }

}
```

为底层来讲，只要两条指令互相之间不影响，不影响我们线程的最终一致性就可以互换，但是JAVA不是这样的。

### 原子性

最理想的结果肯定是100 0000 ，每个线程一人加1万。但是并非如此。因为多个线程共同访问同一个资源产生了竞争，一堆人把一个n=0拿了回去，都对它进行了++，然后写回去，正常来说应该是3但是这样写回去就只是1。这个竞争一般我们称之为叫raise condition。产生竞争就有可能会出现数据的不一致。数据的不一致就是并发访问之下所产生不期望出现的结果。数据的不一致专业名词叫unconsistency就是它数据的没有出现我们所期望的结果。

那如何保障数据的一致呢？这里呢，就有线程同步的概念，所谓的线程同步呢，指的是线程的执行顺序要安排好

```JAVA
public class Code01 {
    private static long n=0L;

    public static void main(String[] args) throws InterruptedException {
        Thread[] threads=new Thread[100];
        CountDownLatch latch=new CountDownLatch(threads.length);
        for (int i = 0; i < threads.length; i++) {
            threads[i]=new Thread(()->{
                for (int j = 0; j < 10000; j++) {
                    n++;
                }
                latch.countDown();
            });
        }
        for (int i = 0; i < threads.length; i++) {
            threads[i].start();
        }
        latch.await();
        System.out.println(n);
    }
}
```

OUTPUT

```
192227
```

前面出现不一致的原因是一个线程把n读出来了，还没写回去呢，这时候别的线程把n的值读走了，所以产生了数据的不一致。只保证我的这份操作对于数据访问的这个操作不被其他线程所打断。在这个时候它就一定会出现数据是一致的。这种不能够被打断的这种操作。称之为原子操作。原操作意思呢，就是不能够中间被打断，只能作为一个整体，不可以中间被其他的线程拉进来同时执行，不能并发执行。

java里面的原子性操作如下。无论是什么语言，java、c++、或者是汇编语言，最终都是翻译成机器语言。即便是汇编语言，它执行的任何一条指令都有可能被其他的线程所打断。所以这个事儿就比较麻烦了，到底哪条语句是原子性的---你不用给它上锁就能保证它的原子性----你得去查汇编手册。

JAVA语言里面有八大原子操作，这几种操作，注意这是虚拟机级别的操作，它并不是语句级别。不用背，只要是你正常的情况下你判断不了这句话到底是不是具备原子型，你给它上锁就行了。

![image-20230404185233892](image/image-20230404185233892.png)

回过头来说上面的代码中n++这个语句为什么不是原子性的。n++一句话，翻译成字节码有这么多。中间这么多的指令，完全有可能被其它线程打断。然后这么多的指令，还要翻译成我们本机的汇编语言，汇编语言还要翻译成机器语言，就更多了。所以是不是原子的，要查cpu的汇编手册。所以归根结底，在你不能够确定某一个操作是原子性的时候，如果我们需要又需要对数据进行同步的时候怎么办？我们就需要有一种机制保障它的操作，一定是原子性的。

![image-20230404190135852](image/image-20230404190135852.png)

保证一定是原子性的----上锁！看到`synchronized`，你就会发现这大括号里面的所有的操作被当成一个整体,不可打断。

```JAVA
public class Code02 {//上锁
    private static long n=0L;

    public static void main(String[] args) throws InterruptedException {
        Thread[] threads=new Thread[100];
        CountDownLatch latch=new CountDownLatch(threads.length);
        for (int i = 0; i < threads.length; i++) {
            threads[i]=new Thread(()->{
                for (int j = 0; j < 10000; j++) {
                    synchronized (Code02.class){
                        n++;
                    }
                }
                latch.countDown();
            });
        }
        for (int i = 0; i < threads.length; i++) {
            threads[i].start();
        }
        latch.await();
        System.out.println(n);
    }
}
```

上锁的本质就是把并发编程序列化。

基本上是同时启动，两秒钟之后同时结束。下面代码就是并发执行

```JAVA
public class Code03 {//上锁的本质
    private static Object o=new Object();//资源对象，当成锁就行

    public static void main(String[] args) {
        Runnable r=()->{
            System.out.println(Thread.currentThread().getName()+"start!");
            SleepHelper.sleep(2);
            System.out.println(Thread.currentThread().getName()+"end!");
        };
        for (int i = 0; i < 3; i++) {
            new Thread(r).start();
        }
    }
}
```

输出：前面三句和后面三句基本上同时输出！

```
Thread-0start!
Thread-1start!
Thread-2start!
Thread-2end!
Thread-0end!
Thread-1end!
```

下面代码进行上锁，资源（锁）是同一个。每个线程都执行了2s，总共花了6s。所以上锁的本质就是从并发操作变成了序列化操作。

```java
public class Code04 {//上锁的本质
    private static Object o=new Object();//资源对象，当成锁就行

    public static void main(String[] args) {
        Runnable r=()->{
            synchronized (o){
                System.out.println(Thread.currentThread().getName()+"start!");
                SleepHelper.sleep(2);
                System.out.println(Thread.currentThread().getName()+"end!");
            }
        };
        for (int i = 0; i < 3; i++) {
            new Thread(r).start();
        }
    }
}
```

输出：并不是同时出来的，每个线程都执行2s

```
Thread-0start!
Thread-0end!
Thread-2start!
Thread-2end!
Thread-1start!
Thread-1end!
```

回头把这段代码上锁，就能保证是100 0000了。让原来的n++并发，变成了序列化。与此同时，synchronized也保障了可见性。注意synchronized本身是可以保障可见性的。就是一个线程结束了之后一定是要跟我的主内存做同步，这样可以保证后面线程拿的数据一定是最新的。但是synchronized不能保障有序性，让synchronized那个大括号里面有很多条指令的时候，这些指令完全有可能换顺序。有序性只是有一个最简单的要求，单线程保障最终一致性，它跟锁没有关系。

```java
public class Code05 {//进行上锁，保证是100 0000
    private static long n=0L;

    public static void main(String[] args) throws InterruptedException {
        Thread[] threads=new Thread[100];
        CountDownLatch latch=new CountDownLatch(threads.length);
        for (int i = 0; i < threads.length; i++) {
            threads[i]=new Thread(()->{
                for (int j = 0; j < 10000; j++) {
                    synchronized (Code05.class){
                        n++;
                    }
                }
                latch.countDown();
            });
        }
        for (int i = 0; i < threads.length; i++) {
            threads[i].start();
        }
        latch.await();
        System.out.println(n);
    }
}
```

来看几个概念

`monitor（管程）`：monitor指的就是我们要上的那把锁。synchronized后面的圆括号里面放的东西我们就称作monitor，监视器。操作系统里面叫做管程，我们叫做锁就行了。

`critical section`：临界区。当我持有这把锁的时候，我所执行的这些代码就是是临界区。也就是synchronized后面大括号包着的。如果临界区它执行的时间比较长、语句比较多，一般我们称之为锁的粒度比较粗。反之就是锁的粒度比较细。

所谓上锁就是保证一个操作的原子性，保证整个critical section里面的这一系列操作的原子性。不管你是n加加，不管你里面有多少行多少行代码，我要保证你的原子性。怎么才能保障呢？一共有两种方式。第一种，我们可以称之为悲观锁。第二种我们称之为乐观锁。

看到synchronized就知道是一个悲观锁，不管有没有人，我一定要锁上。

1. 悲观的认为这个操作会被别的线程打断(悲观锁)     synchronized (上一个小程序)

2. 乐观的认为这个操作不会被别的线程打断(乐观锁 自旋锁 无锁)    cas操作

   CAS = Compare And Set/Swap/Exchange

来看cas的概念。举个例子，我不上锁，所有人都可以拿这个n，我拿了这个n先去++，然后要写回的时候看看主内存里面那个值和我最开始拿来的那个值是不是一样的，如果一样，那么说明没有人改过，我可以写进去。如果不一样，那么说明有人来改过这个值，我就再把这个n拿回来，再执行一次，然后再去比对，一直循环，直到有一次成功了。

这里面会产生这种，你看此零非彼零的问题。就是著名的aba问题。你要写回的时候，看到这个n依然是0，但是可能这个n已经被别人从0--->xxx---> .....  --->  0 ,中间可能已经经历了一系列的变化。aba就是a被改成了b但是最后又变成了a。在很多情况下，我们不在乎的情况下，无所谓略过，aba问题不用去解决它。但是在有些情况下你是必须要解决它。如果你拿的这个a是一个对象的引用，你把这个a拿走了，做了一些改变，你现在要写回去，这个a可能已经被别人修改了，但是a依然是那个引用，这个时候就要注意aba问题了。那这时候该怎么解决呢，给它加一个version就可以了。加版本有两种加法，第一种呢是带时间戳，或者是带数字，第二种呢就是布尔类型。

除了aba问题之外CAS还有一个巨大个的问题，这个问题非常的严重。因为CAS是先比较然后才写，所以是先判断，然后才会写。这是分了两步操作，所以要要用CAS来保证原子性，由于CAS是用两步操作来保证的，那么CAS本身一定要是原子性的，那么CAS是如何保证本身是原子性的呢？

![image-20230404194000883](image/image-20230404194000883.png)

这里`incrementAndGet()`这步操作就是我每次往回写的时候都要比较一下，看看是不是依然是我期望那个值，如果不是我期望的，我就再来一遍。`AtomicInteger`意思就是它的增加操作是原子性的。

```JAVA
public class Code06 {//用乐观锁的方式玩一次n++，用AtomicInteger这个类
    AtomicInteger n=new AtomicInteger();

    void m(){
        for (int i = 0; i < 10000; i++) {
            n.incrementAndGet();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Code06 t=new Code06();
        Thread[] threads=new Thread[100];
        for (int i = 0; i < threads.length; i++) {
            threads[i]=new Thread(t::m,"thread-"+i);
        }
        for (int i = 0; i < threads.length; i++) {
            threads[i].start();
        }
        for (int i = 0; i < threads.length; i++) {//让主线程等着100个线程全部执行完
            threads[i].join();
        }
        System.out.println(t.n);
    }
}
```

如何保障？看看源码，可以发现它有一个比较的过程，最后追到了native---c++代码。追到底层调用了unsafe那个类的某些方法，unsafe这个类的方法又调用了native的本地代码C加加写的compare and set int的方法。

<img src="image/image-20230404200424293.png" alt="image-20230404200424293" style="zoom:67%;" />

<img src="image/image-20230404200446408.png" alt="image-20230404200446408" style="zoom:50%;" />

<img src="image/image-20230404200505958.png" alt="image-20230404200505958" style="zoom:50%;" />

<img src="image/image-20230404200534470.png" alt="image-20230404200534470" style="zoom:50%;" />

<img src="image/image-20230404200552362.png" alt="image-20230404200552362" style="zoom:50%;" />

最后调用这个compare and exchange这个操作。

![image-20230404201020736](image/image-20230404201020736.png)

is_MP()的意思就是看看你是不是multi-processor，多核的CPU。然后调用了_ asm _这个汇编指令，发现CPU本身就有一个源语指令是compare and exchange。

![image-20230404232922367](image/image-20230404232922367.png)

如果你要用CAS操作的话，首先得益于我们的CPU它在汇编指令级别上支持一条指令，就是compare and exchange。我们通过总线访问这个内存的时候，本身就支持cas操作，它完全可以把这个值读过来往回写的过程之中比较，哥们，你是不是还是原来那个零？在底层就直接支持。

`cmpxchg`这条指令在CPU（多核）里面也不是原子的，CPU的指令是不是原子的，会不会被打断，需要去查汇编手册。也就是说，如果你执行这条指令的过程之中，你把它读过来，写成1往回写的过程之中，完全有可能被另外一颗CPU读过来，已经写回去了。所以这条指令会出问题。所以办法就是`lock cmpxchg `，直接对多核cpu进行lock，防止被别的cpu读走。这个CPU在对这个值进行修改的时候，把总线锁住，等我改完了，总线放开其他CPU才能去访问这块内存。这个锁可以是缓存锁，也可以是总线索，看情况而定。所以你会发现。cas的我们在宏观上把它叫做叫自旋锁、乐观锁，但它在底层的实现、在微观上的实现，它实际上是一个悲观锁。

多核才加lock单核就不用加了，因为cmpxchg对于一颗cpu来说就是原子的，只不过在有多个cpu的时候这个指令就不是显现成原子的了。

来讨论一下乐观、悲观两种锁的效率。千万不要说乐观锁的效率一定比那个悲观锁效率高，不一定。

这个悲观锁往往是采用什么样的方式来实现的？和这个锁所关联的会有一个队列，这个队列用来等待着这把锁，凡是在队列里等待的这些线程它是不消耗CPU资源的，它等着。乐观锁什么样，乐观锁是转圈儿，我要循环查看锁释放了没，并不是像上面那样乖乖等着操作系统来调度，这些线程是消耗CPU的。CPU一个是要运行它们的well循环，一个是要进行线程的切换。等待队列里不一样，等待队列这些线程是不占用CPU的，它的状态是叫parking、waiting、blocked阻塞的，不占用CPU，什么时候操作系统说轮到你了，你再出来占CPU，我再调度你。

重量级临界区执行的时间比较长，锁的力度比较粗，同时等的人很多，用悲观锁。如果临界区执行的时间比较短，那就可以用乐观锁。量化，如果你真的要追求这一点，自己去做压测。你可以写两种锁的实现。来看看哪种更合适。压测的结果支持哪一种就用哪一种。

我说一个比较实战的，实战您就用synchronized。因为synchronized现在做了一系列的优化，在它内部既有自旋锁、偏向锁，又有重量级锁进行自适应的升级过程，它的效率已经调试的很不错了。

再来看看synchronized如何保证可见性。前面说了synchronized是一个上锁的过程，那么就有lock，有lock就有unlock，unlock是可以保证可见性的。在我们解锁之后，它会要把所有的内存的状态跟我们本地的缓存做一个刷新，然后下一个线程才能继续。

## synchronized

![image-20230405155801245](image/image-20230405155801245.png)

如果说想了解synchronized的话呢，首先要补几个基础。第一个基础呢叫cas，compare and swap。具体的原理前面有说。CAS的一种使用就是AtomicInteger，使用它的时候是不需要加锁的，由于不用加锁所以incrementAndGet这个方法一定本身是原子性的。

```JAVA
public class Code06 {//用乐观锁的方式玩一次n++，用AtomicInteger这个类
    AtomicInteger n=new AtomicInteger();

    void m(){
        for (int i = 0; i < 10000; i++) {
            n.incrementAndGet();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Code06 t=new Code06();
        Thread[] threads=new Thread[100];
        for (int i = 0; i < threads.length; i++) {
            threads[i]=new Thread(t::m,"thread-"+i);
        }
        for (int i = 0; i < threads.length; i++) {
            threads[i].start();
        }
        for (int i = 0; i < threads.length; i++) {//让主线程等着100个线程全部执行完
            threads[i].join();
        }
        System.out.println(t.n);
    }
}
```

了解用户态和内核态。要讲清synchronized它的升级过程，大家要了解用户态和内核态。现在的操作系统基本上都会把一些指令分成级别。作为操作系统内核，我所有的指令都可以访问。但是作为用户空间，有些指令你可以访问，有些指令你得向操作系统内核申请才能访问。这就在逻辑上把整个的内存空间、或者叫内存的执行过程，或者叫程序的执行过程，分成了两种状态，第一种叫内核态，第二种叫用户态。

这种设计方式，操作系统在经过了一系列的升级，才达到这种方式，这种方式现在目前在硬件上是支持的。像英特尔的CPU，它本身就支持四种级别的分布。从ring 0级一直到ring 3级，Linux内核工作在rain 0级，它能够访问所有指令。linux的用户空间的程序工作在ring 3级，某些指令是不能直接访问的。

在jdk最开始的时候，synchronized也叫做重量级锁。对操作系统内核来说，你JVM也仅仅是工作在我的用户态。锁（lock）这个资源是要通过操作系统才能去申请到的。所谓的上重量级锁的意思就是我JVM现在要对某一个资源加锁了，你要对这个资源加锁的时候，你得向操作系统申请一把锁，通过一个从用户态到内核态的系统调用，著名的0x80。

从JVM往OS申请锁的时候，是要经过一个中断的调用。也就是说，我申请了这把锁之后，我要把这锁返回去还需要从内核态返回到用户态。所以它叫重量级锁的原因就在于它申请这把锁的时候都需要经过操作系统。都需要经过用户态到内核态的一个转换。现在synchronized做了一些优化，在某些状态之下，它是不需要向操作系统老大去申请，只需要在用户空间就可以解决问题。

还需要补一个东西，现在很多大厂都会问这个问题，你了不了解一个对象的内存布局？什么叫做对象的内存布局，就是当我们new一个对象出来的时候，它在内存里头到底是怎么分布的。new出一个对象来之后，这个对象在内存之中怎么分布这件事是跟特定的JVM虚拟机实现有关系的，今天讲的是hospot实现。

new出这个对象来之后，比如说我们有一个类class T，里边儿有一个小的成员变量叫m ，int的类型，它等于几无所谓。当我们new一个小t对象，new出来之后，放到堆内存里，首先，上面有八个字节的Markword--标记字节。在默认的情况下面还有四个字节的class pointer，四个字节的类型指针，通过它可以找到我们`T.class`这个类。接下来是它的成员变量instance data，刚才我们说了是一个int类型，int类型占四个字节，所以这里又有四个字节。一个对象在Hospot里面实现它要求这个对象八字节对齐，八字节对齐的意思就是这个对象大小（字节数）务必是八的整数倍，如果前面不够，后面需要补。我们用一个工具来证明它，这个工具叫JAVA object layout--JOL。这工具是来源于open jdk，在你的程序里面加maven依赖就可以了。

依赖：

```
        <dependency>
            <groupId>org.openjdk.jol</groupId>
            <artifactId>jol-core</artifactId>
            <version>0.9</version>
        </dependency>
```

```
public class Code02_JOL {
    public static void main(String[] args) throws Exception{
        Thread.sleep(5000);
        Object o=new Object();
        System.out.println(ClassLayout.parseInstance(o).toPrintable());//打印它的内存布局
//        synchronized (o){
//            System.out.println(ClassLayout.parseInstance(o).toPrintable());
//        }
    }
}
```

OUTPUT

![image-20230405165318735](image/image-20230405165318735.png)

比较一下，如果把注释去掉会是如何

```JAVA
public class Code02_JOL {
    public static void main(String[] args) throws Exception{
        Thread.sleep(5000);
        Object o=new Object();
        System.out.println(ClassLayout.parseInstance(o).toPrintable());//打印它的内存布局
        synchronized (o){
            System.out.println(ClassLayout.parseInstance(o).toPrintable());
        }
    }
}
```

如果随着的synchronized越来越复杂的时候，前面两行是不一样的，前两行叫做markword。在这里你就会发现了，原来我们所谓的上锁给对象上锁指的是一件什么事儿？在hospot里面的实现就是修改Markword。所以锁信息它被记录在了markword里面。

![image-20230405165903333](image/image-20230405165903333.png)

关于markword这个东西它里面记录了非常重要的信息，最重要的信息就是锁。Markword里面还记录了什么呢？实际上，它还记录了gc的信息，还记录了hashcode。如果大家伙想弄清楚一个markword里面它到底详细的记录了什么？大家找到hotspot源码MarkOop.hpp文件。记录了下图所示的信息。

![image-20230405170202107](image/image-20230405170202107.png)

来我们讲我们的synchronized这个升级的过程。最开始的时候呢，这个synchronized全是重量级锁，后来呢JAVA对synchronized做了一系列的优化。这个优化的过程主要是在没有必要的时候，我没有完全没有必要向操作系统申请重量级锁。锁升级的过程到底是什么样子的？是通过什么来标志的呢？锁升级过程就是通过markword后面这几位来标志的。

锁目前有好几种状态。看下图，锁升级的一个最主要的一个流程图。当我们new出一个普通对象来的时候，它有可能是两种状态，两种状态的意思是。new出来这种对型类型的对象a，它的Markword是一种形式。new出来这种类型的对象b，它的Markword是一种形式。我们刚刚new出来的对象object，像这种对象就叫普通对象。还有一种情况，我们会new出来匿名偏向对象。

看一条主线，当我们首先new一个普通对象出来，它会升级为偏向锁，变完偏向锁之后，如果竞争一旦激烈，它会变成轻量级锁，轻量级锁也是我们俗称的自旋锁、无锁。竞争再加剧会变成重量级锁，也就是我们最开始的向操作系统老大申请的那把锁。

怎么区分锁的状态？在Markword里面，优先看最低的两位，最低两位如果是00，那代表的是轻量级锁。最低两位如果是10代表的是重量级锁。最低两位，如果是11说明这个对象正在被回收gc回收。最低两位如果是01，它包含两种有可能的状态，第一种呢是无锁态，也就是我们刚刚new出来的普通状态，第二种是偏向锁，所以在最低位是01的情况下，还需要再加一位来指明是偏向锁还是无锁态。看上图，发现我们的锁是偏向锁。

先来看脉络。偏向锁和轻量级锁这两把锁叫做用户空间锁。我不需要向操作系统申请，少了申请的过程。

![image-20230405170527189](image/image-20230405170527189.png)
